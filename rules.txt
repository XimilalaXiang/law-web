rule_0: 注意，遇到问题后，不要瞎猜。要深入思考。系统思考要调用你的 MCP 来进行多轮的查询，深入分析我们的代码框架，分析我们的代码结构，查询相关的资料。调用你的 FireCrawl 的 MCP 去查询，而不要在这里瞎猜。瞎猜解决不了问题，只会导致失败。coding的时候必须查看这个文件@rules.txt
rule_1: 全程和用户交互时，必须调用mcp-feedback-enhanced的mcp, 我也希望我和你之间的交互通过这个mcp,而不是通过客户端。 你不得在Cursor的客户端上主动终止和用户的对话。 想和用户进行交互，需要通过mcp-feedback-enhanced的mcp。（用户有时会出于某些原因而主动中断对话，但你不能主动发起中断对话。）
rule_2: 思考时，必须调用sequential thinking的mcp
rule_3: 联网搜索时，必须调用firecrawl-mcp的mcp
rule_4: 调试相关功能时，需要真实浏览器环境时，使用浏览器来完成工作才效果最好时，必须调用chrome-mcp-server的mcp
rule_5: 我希望我们使用Git来进行版本备份，每当完成一个功能后，当你检测完成后，通过mcp-feedback-enhanced向我反馈，等待我进行检查。当我检测通过后，向你输出（我有时会忘了提醒你进行 Git，你需要辨别，当我推进你的下一个功能时，这意味着现在的功能已经通过了我的检测。此时，就要进行 git），随后，你就要进行git
rule_6: 你可以生成测试文件来进行测试。但是，当测试完成后，你需要把测试文件的功能放入到我们的主要文件中。接着，我们再来测试主要文件是否能够完成功能。如果可以完成，那么此时把之前的测试文件删掉；如果不能完成，那么思考如何修改，接着重复进行。
rule_7: 当需要管理GitHub issues，如查询issue时，必须调用github-issue的mcp
rule_8: 当需要确保AI对话连续性、防止过早终止、或管理项目内存规范时，必须调用cunzhi的mcp
rule_9: 当进行浏览器自动化测试、跨浏览器交互或刮取时，如果chrome-mcp-server不合适，必须调用playwright的mcp
rule_10: 当需要获取最新版本特定文档、代码示例或上下文信息时，必须调用context7-mcp的mcp